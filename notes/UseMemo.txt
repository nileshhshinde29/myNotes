useMemo hooks

- if our code contains a heavy function, and it runs at every render 
  because of that our code littel bit slower ,
- to avoid that we use useMemo Hook

- the function within the useMemo Hook will runs only there is change happens into the passed dependency
 
const result = useMemo(()=>{

    return factorial(Count)

} , [Count] ) 



-The useMemo is similar to useCallback hook as it accepts a function and a list of dependencies 
but it returns the "memoized value" returned by the passed function. It recalculated the value only 
when one of its dependencies change. 
It is useful to avoid expensive calculations on every render when the returned value is not going to change.

---------------------------------------------------------------------------------------------------------------------

useCallback Hook:

- eg. 
  const displayName = () =>{
      return setName('hello');
  }

  this function converted to useCallback in below
    
const displayName = useCallback(()=>{

    return setName('hello')

} , [name] ) 

the  useMemo  & useCallback hook nearly about same
the useMemo use to  memorize the value , useCallback use to memorize function


-----------------------------------------------------------------------------------

Custom Hook

const useTitleCount= (count)=>{
    useEffect(()=>{
        if(count>=1)
        {
            document.title= `title ${ count }`
        }
        else
        {
             document.title= `title`
        }

    }, [ count ])
}

make this an separate component whenever require just import it and  use it

eg. useTitleCount( count )

- Custom Hooks are a mechanism to reuse stateful logic 
- The main reason to write a custom hook is for code reusability. 
    For example, instead of writing the same code across multiple components that use
    the same common stateful logic (say a “setState” or localStorage logic),
    you can put that code inside a custom hook and reuse it.

---------------------------------------------------------------------------------------------------------

UseReduser hook

const initialState = 0

const reducer= (state, action ) =>{
 if( action.type === "INCREMENT")
 {
     return state+1
 }
 if( action.type ==="DECREMENT")
 {
     return  state - 1
 }
 return state
}


const UseReduser =()=> {

    const [state , dispatch] = useReduser( reducer , initialState)

    return (

        <button onclick={ ()+.dispatch({type : "INCREMENT" })}>inc <button>
        <button onclick={ ()+.dispatch({type : "DECRIMENT" })}>Dec <button>

    )
}
----------------------------------------------------------------------------------------------
eg 2
const initialState ={ count :0,
                      count2 :1,}
                                
 
          const reducer = (state, action) => {
           
            switch (action.type) {
              case 'inc1':
                return {...state , 'count':state.count+1 }
              case 'inc2':
                return { ...state,  'count2': state.count2 + 1 };
              default:
                return state
            }
            return(state)
          }

          const [state ,dispatch]= useReducer(reducer , initialState)

         

          return (
            <><div> {state.count}</div>
              <div>  { state.count2}</div>
              
              <button onClick={()=> dispatch({type:"inc1"})}> Count1</button>,
              <button onClick={()=> dispatch({type:"inc2"})}> Count2</button>
            </>
          );
        }











